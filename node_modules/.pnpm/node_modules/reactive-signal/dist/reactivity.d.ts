type Subscriber = () => void;
export interface Component {
    queuedUpdate: () => void;
    [key: string]: any;
    _tempActiveUpdateFnName?: string;
}
export declare function setActiveComponent(component: Component, updateFnName?: string): void;
export declare function clearActiveComponent(): void;
export declare function getActiveComponent(): Component | null;
export declare class Signal<T> {
    private _value;
    private subscribers;
    depsComponents: Set<Component>;
    constructor(value: T);
    get value(): T;
    set value(newValue: T);
    peek(): T;
    update(): void;
    subscribe(callback: Subscriber): void;
    unsubscribe(callback: Subscriber): void;
    private notifying;
    private notify;
}
export declare class Computed<T> {
    private computeFn;
    private _value;
    private dependencies;
    private subscribers;
    depsComponents: Set<Component>;
    constructor(computeFn: () => T);
    get value(): T;
    peek(): T;
    private notifying;
    private compute;
    private recompute;
    subscribe(callback: Subscriber): void;
    unsubscribe(callback: Subscriber): void;
    private notify;
    addDependency(dep: Signal<any> | Computed<any>): void;
}
export declare class Effect {
    private effectFn;
    private dependencies;
    private disposed;
    constructor(effectFn: () => void);
    run: () => void;
    addDependency(dep: Signal<any> | Computed<any>): void;
    private cleanup;
    dispose(): void;
}
export declare function signal<T>(value: T): Signal<T>;
export declare function computed<T>(computeFn: () => T): Computed<T>;
export declare function effect(effectFn: () => void): () => void;
export declare function batch(fn: () => void): void;
export type SignalObject<T> = {
    [K in keyof T]: Signal<T[K]>;
};
export declare function signalObject<T>(initialValues: T): SignalObject<T>;
export {};

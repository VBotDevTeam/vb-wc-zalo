{"version":3,"file":"index.cjs","sources":["../src/reactivity.ts"],"sourcesContent":["type Subscriber = () => void;\n\nlet activeEffect: Effect | null = null;\nlet isBatching = false;\nlet pendingSubscribers: Set<Subscriber> = new Set();\n\nexport interface Component {\n  queuedUpdate: () => void\n  [key: string]: any\n  _tempActiveUpdateFnName?: string\n}\n\nlet activeComponent: Component | null = null\n\nexport function setActiveComponent(\n  component: Component,\n  updateFnName?: string,\n): void {\n  activeComponent = component\n  activeComponent._tempActiveUpdateFnName = updateFnName || 'queuedUpdate'\n}\n\nexport function clearActiveComponent(): void {\n  activeComponent = null\n}\n\nexport function getActiveComponent(): Component | null {\n  return activeComponent\n}\n\n\nexport class Signal<T> {\n  private _value: T;\n  private subscribers: Set<Subscriber> = new Set();\n  depsComponents = new Set<Component>()\n  constructor(value: T) {\n    this._value = value;\n  }\n\n  get value(): T {\n    // 没有在通知，才能添加依赖，否则会导致循环依赖\n    if (!this.notifying) {\n      if (activeEffect) {\n        // computed 内部触发的原始信号的 get value 不用加入原始信号的订阅\n        if (activeEffect.run) {\n          this.subscribe(activeEffect.run);\n        }\n        activeEffect.addDependency(this);\n      }\n    }\n\n    const component = getActiveComponent()\n    if (component) this.depsComponents.add(component)\n    return this._value;\n  }\n\n  set value(newValue: T) {\n    // 修改前也有 hook？\n    if (newValue !== this._value) {\n      this._value = newValue;\n      this.update();\n    }\n  }\n\n  peek() {\n    return this._value;\n  }\n\n  update() {\n    this.notify();\n    this.depsComponents.forEach(\n      (component) => component[component._tempActiveUpdateFnName!]?.(),\n    )\n    // 信号值修改后 hook，重置已经执行的 effect\n    this.subscribers.forEach(callback => {\n      // 重置计算属性的 subscribers，防止不依赖 signal 但依赖 computed的 effect不执行\n      // @ts-ignore\n      if (callback.computedInstance) {\n        // @ts-ignore\n        callback.computedInstance.subscribers.forEach(callback => {\n          callback.done = false;\n        });\n      }\n      // @ts-ignore\n      callback.done = false;\n    });\n  }\n\n  subscribe(callback: Subscriber) {\n    this.subscribers.add(callback);\n  }\n\n  unsubscribe(callback: Subscriber) {\n    this.subscribers.delete(callback);\n  }\n\n  private notifying = false;\n  private notify() {\n    if (isBatching) {\n      this.subscribers.forEach(callback => pendingSubscribers.add(callback));\n    } else {\n      this.notifying = true;\n      this.subscribers.forEach(callback => {\n        // @ts-ignore\n        if (typeof callback === 'function' && !callback.done) {\n          // @ts-ignore\n          callback.done = true;\n          callback();\n        }\n      });\n      this.notifying = false;\n    }\n  }\n}\n\nexport class Computed<T> {\n  private computeFn: () => T;\n  private _value: T;\n  private dependencies: Set<Signal<any> | Computed<any>> = new Set();\n  private subscribers: Set<Subscriber> = new Set();\n\n  depsComponents = new Set<Component>()\n\n  constructor(computeFn: () => T) {\n    this.computeFn = computeFn;\n    this._value = this.compute();\n  }\n\n  get value(): T {\n    if (!this.notifying) {\n      if (activeEffect) {\n        this.subscribe(activeEffect.run);\n        activeEffect.addDependency(this);\n      }\n    }\n    const component = getActiveComponent()\n    if (component) this.depsComponents.add(component)\n    return this._value;\n  }\n\n  peek() {\n    return this._value;\n  }\n\n  private notifying = false;\n  private compute(): T {\n\n    const previousEffect = activeEffect;\n    // @ts-ignore\n    activeEffect = this;\n    const newValue = this.computeFn();\n    activeEffect = previousEffect;\n\n    return newValue;\n  }\n\n  private recompute = () => {\n    const newValue = this.compute();\n    if (newValue !== this._value) {\n      this._value = newValue;\n      this.notify();\n      this.depsComponents.forEach(\n        (component) => component[component._tempActiveUpdateFnName!]?.(),\n      )\n    }\n  }\n\n  subscribe(callback: Subscriber) {\n    if (callback) {\n      this.subscribers.add(callback);\n    }\n  }\n\n  unsubscribe(callback: Subscriber) {\n    this.subscribers.delete(callback);\n  }\n\n  private notify() {\n    if (isBatching) {\n      this.subscribers.forEach(callback => pendingSubscribers.add(callback));\n    } else {\n      this.notifying = true;\n      this.subscribers.forEach(callback => {\n        // @ts-ignore\n        if (!callback.done) {\n          // @ts-ignore\n          callback.done = true;\n          callback();\n        }\n      });\n      this.notifying = false;\n    }\n  }\n\n  addDependency(dep: Signal<any> | Computed<any>) {\n    this.dependencies.add(dep);\n    // 订阅重新计算\n    dep.subscribe(this.recompute);\n    // @ts-ignore\n    this.recompute.computedInstance = this;\n  }\n}\n\nexport class Effect {\n  private effectFn: () => void;\n  private dependencies: Set<Signal<any> | Computed<any>> = new Set();\n  private disposed = false;\n\n  constructor(effectFn: () => void) {\n    this.effectFn = effectFn;\n    this.run();\n  }\n\n  run = () => {\n    if (this.disposed) return;\n    const previousEffect = activeEffect;\n    activeEffect = this;\n    this.effectFn();\n    activeEffect = previousEffect;\n  }\n\n  addDependency(dep: Signal<any> | Computed<any>) {\n    if (this.disposed) return;\n    this.dependencies.add(dep);\n    // @ts-ignore\n    this.run.effectInstance = this;\n    dep.subscribe(this.run);\n  }\n\n  private cleanup() {\n    this.dependencies.forEach(dep => dep.unsubscribe(this.run));\n    this.dependencies.clear();\n  }\n\n  dispose() {\n    this.cleanup();\n    this.disposed = true;\n  }\n}\n\n// Factory functions\nexport function signal<T>(value: T): Signal<T> {\n  return new Signal(value);\n}\n\nexport function computed<T>(computeFn: () => T): Computed<T> {\n  return new Computed(computeFn);\n}\n\nexport function effect(effectFn: () => void): () => void {\n  const eff = new Effect(effectFn);\n  return () => eff.dispose();\n}\n\nexport function batch(fn: () => void) {\n  isBatching = true;\n  try {\n    fn();\n  } finally {\n    isBatching = false;\n    pendingSubscribers.forEach(callback => {\n      // @ts-ignore\n      if (!callback.done) {\n        // @ts-ignore\n        callback.done = true;\n        callback();\n      }\n    });\n    pendingSubscribers.forEach(callback => {\n      // @ts-ignore\n      callback.done = false;\n    });\n    pendingSubscribers.clear();\n  }\n}\n\nexport type SignalObject<T> = {\n  [K in keyof T]: Signal<T[K]>\n}\n\nexport function signalObject<T>(initialValues: T): SignalObject<T> {\n  const signals = Object.entries(initialValues as object).reduce(\n    (acc, [key, value]) => {\n      acc[key] = signal<T[keyof T]>(value as T[keyof T])\n      return acc\n    },\n    {} as { [key: string]: Signal<T[keyof T]> },\n  )\n\n  return signals as SignalObject<T>\n}\n"],"names":["activeEffect","isBatching","pendingSubscribers","Set","activeComponent","getActiveComponent","Signal","value","_value","subscribers","this","depsComponents","notifying","_proto","prototype","peek","update","notify","forEach","component","_component$component$","_tempActiveUpdateFnName","call","callback","computedInstance","done","subscribe","add","unsubscribe","_createClass","key","get","run","addDependency","set","newValue","Computed","computeFn","_this","dependencies","recompute","compute","_component$component$2","_proto2","previousEffect","dep","Effect","effectFn","_this2","disposed","_proto3","effectInstance","cleanup","_this3","clear","dispose","signal","fn","eff","updateFnName","initialValues","Object","entries","reduce","acc","_ref"],"mappings":"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"}